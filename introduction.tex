\section{Introduction}\label{sec:introduction}

A blockchain is a list of \emph{blocks}, each reporting the hash
of its previous block, satisfying some consistency or \emph{consensus} rules.
Blocks hold \emph{transactions}, whose exact nature is not relevant here.
In general, they are requests to update the state of a global abstract machine:
a ledger of payments (as in Bitcoin~\cite{Nakamoto08,Antonopoulos17})
or a sort of global RAM where data structures are allocated and modified
(as in Ethereum~\cite{AntonopoulosW18}).
By using hashes as machine-independent
pointers, blockchains can be distributed in a network of peers.
This is desirable since data gets safely duplicated
and no special peer determines the history alone.
However, peers expand the blockchain at will, independently from the other
peers, hence the blockchain becomes a tree rather than a list.
A notion of chain quality is used to incentivize peers to append blocks to the highest-quality chain
(the \emph{best} chain).
Therefore, a peer might replace its current best chain with another, even better chain,
a so called \emph{history change}.

As presented above, peers are free to generate new blocks at maximal speed, flood the network
with new blocks and make difficult the emergence of a best chain, with frequent history changes.
This is an efficiency and security issue: history changes allow
\emph{double spending}, when the same money is moved in the ledger twice, once in the current history
and once in the updated history. The actual genious of Nakamoto~\cite{Nakamoto08} was to
(largely) solve this issue with a consensus rule requiring blocks to answer a \emph{challenge}
contained in their previous block. Namely, the binary hash of each block must be smaller than
a \emph{difficulty} value computed at the previous block, directly bound to the quality of the chain.
Therefore, who creates (\emph{mines}) of a new block runs a \emph{proof of work} algorithm
that rotates (\emph{grinds}) many alternative values for a block field, called \emph{nonce}, until
the hash of the block is smaller than the difficulty. This complicates the creation of new blocks,
makes it impossible to create blocks at arbitrary speed and introduces an
incentive to expanding the best chain only, rather than creating alternative histories by mining at multiple chains,
since otherwise the miner
risks spending work (concretely, electricity) for creating blocks discarded by its peers.
A miner gets remunerated for its work whenever it finds a new block before all other miners.

The \emph{proof of work} is a brute-force algorithm,
because of the non-correlation property of hash functions.
Therefore, it consumes energy: Bitcoin is said to consume as much electricity as
a medium-sized country; moreover, it is not egalitarian, being
worthwhile only in countries where electricity is cheap; furthermore, it
runs more efficiently over dedicated, relatively expensive hardware (such as ASICs),
against the promise of a democratic and open network.
Therefore, the current trend is towards the \emph{proof of stake}.
This comes in different flavors, but
the common idea is that mining is limited to a (static or dynamic, exclusive or delegatable)
set of peers, that \emph{stake} a collateral to buy mining rights.
Many criticize proof of stake for being centralized and undemocratic
(\emph{rich becomes richer}).
Moreover, it suffers from what we call a \emph{start-up issue}: as long as the cryptocurrency
of a newborn blockchain has still no value, it is hard to convince miners to work and
be updated, since there is no incentive for that. Moreover, miners in
a proof of stake blockchain get punished (\emph{slashed}) if they misbehave or are offline, which
might be perceived as unfair if that happens because of a connectivity issue or black-out.

An alternative to proof of work and proof of stake is
\emph{proof of space}~\cite{AtenieseBFG14,DziembowskiFKP15}, where
miners must dedicate a large chunk of disk memory for answering challenges.
Its energy consumption is close to zero and no special
hardware helps for mining, currently: the technology is both cheap
and democratic. Moreover, proof of space allows
one to capitalize on unused memory, for free, while proof of work has always an
inherent electricity cost.
For fairness, proof of space protocols should only allow to generate answers of
quality directly proportional to the allocated space, or otherwise they are said
to suffer from a time/memory tradeoff.
Moreover, \cite{ParkKFGAP18} shows that
cheap answers actually introduce new security attacks,
known as \emph{nothing-at-stake} problems, such as \emph{block grinding},
\emph{challenge grinding} and \emph{mining on multiple chains},
and proposes solutions to cope with them.
These attacks increase the risk of double spending and make it convenient
(\emph{rational}) to mine through space \emph{and} work, therefore neutralizing the benefits
of proof of space.
Another nothing-at-stake problem, that has not received great attention up to now,
is the \emph{newborn attack}~\cite{TangZDWLG0L19}: a miner that has allocated a large space
for mining for a blockchain network $N$ could use the same space, unchanged, for
mining for a newborn, small network $N'$. If the total space used by the peers of $N'$ is
initially relatively small, it could be possible for the miner to hijack the history of $N'$,
effectively taking its control. These attacks are anti-economic with proof of work,
since computing power can only be dedicated to one mining task.

Most theoretical formalizations of proof of space~\cite{AtenieseBFG14,DziembowskiFKP15,RenD16} are
based on challenges against graphs of high pebbling complexity, but
no actual blockchain has ever been built using such theory: only SpaceMint, a prototype and non-maintained
implementation of the protocol, exists~\cite{ParkKFGAP18}. This has two reasons:
%
\begin{enumerate}
\item the protocol includes an \emph{initialization phase},
  run for each new prover (miner) that joins the blockchain,
  that complicates the protocol itself and
  requires to spend cryptocurrency even \emph{before}
  starting mining. Compare this with Bitcoin, for instance, that allows one to start mining
  and \emph{later} collect cryptocurrency. This initialization is a barrier against new
  miners, that is, a limit to democracy;
\item as stated in~\cite{AbusalahACKPR17}, answers to challenges (called \emph{proofs}),
  included in blockchain, are relatively large:
  kilobytes or even megabytes for proofs created in the initialization phase.
\end{enumerate}
%
The only full-fledged implementation of a proof of space blockchain is Signum~\cite{Signum},
that is not based on graph pebbling.
In Signum, each miner allocates a large \emph{plot file} of hashes, that is not shared nor
stored in blockchain.
A peer that wants to mine the next block derives a challenge from the current head of the blockchain
and challenges the miner for an answer, called
\emph{deadline}\ie a small (around $200$ bytes) data structure, derived from the plot, with a quality measure
(its \emph{waiting time}) that, on average, is proportional to the size of the plot file.
Signum's protocol is attractive since it has no initialization phase (each miner creates its plot file
independently and off-line) and its answers are very small.
But the theory behind Signum has never been formalized
or even defined up to now.
Moroever, \cite{ParkKFGAP18}~warns about a potential block grinding attack and
a time/memory tradeoff, that the developers of Signum have allegedly solved,
but nothing has been proved nor published about it. Without a formalization, it is
even impossible to judge if such attacks are real.

Therefore, this paper provides the following contributions to Signum's algorithm:
%
\begin{itemize}
\item a formalization of the algorithm, recostructed and interpolated from a very informal and partial
  web description~\cite{SignumPlotting} and its poorly commented source code~\cite{SignumSource};
\item a proof that the block grinding attack hinted in~\cite{ParkKFGAP18} cannot actually occur;
\item a protection against challenge grinding and mining on multiple chains attacks, inspired by~\cite{ParkKFGAP18};
\item a protection against newborn attacks.
\end{itemize}
%
These results are relevant since they show that the only implementation
of a blockchain, purely based on proof of space, is actually supported by a formal theory
and can be protected from a large class of attacks.

The rest of this paper is organized as follows.
Sec.~\ref{sec:nonces_and_plots} formalizes structure and initialization of the space used for mining.
Sec.~\ref{sec:challenges_and_deadlines} defines the challenges that the proof of space
algorithm must solve, and their answers, called \emph{deadlines}.
Sec.~\ref{sec:blockchain_construction} presents the blockchain and the mining algorithm
based on proof of space.
Sec.~\ref{sec:attacks_and_protections} considers grinding and newborn attacks and
shows if the algorithm is subject to such attacks and how to cope with them.
Sec.~\ref{sec:related_work} discusses related work.
Sec.~\ref{sec:conclusion} concludes the paper.

\vspace*{1ex}
\textbf{Acknowledgments:}
We thank the developers of Signum for discussions on their Discord channel (where, however, most
of our questions remained unanswered) and K.\ Pietrzak for discussing solutions to
grinding attacks and theoretical issues about Signum.
