\section{Introduction}\label{sec:introduction}

A blockchain is a list of \emph{blocks}.
Each block $b$ refers to a previous block $p$ through its hash.
Blocks satisfy some consistency or \emph{consensus} rules.
Blocks hold \emph{transactions}, whose exact nature is not relevant here.
In general, they are requests to update the state of a global abstract machine:
a ledger of payments (as in Bitcoin~\cite{Nakamoto08,Antonopoulos17})
or a sort of global RAM where data structures can be allocated and modified
(as in Ethereum~\cite{AntonopoulosW18}).
By using hashes as machine-independent
pointers, blockchains can be distributed in a network of peers.
This is desirable since data gets safely duplicated
in each peer and there is no special peer that determines the
transactions history.
However, peers are free to expand the blockchain at will, independently from other
peers, and the blockchain becomes a tree rather than a list.
A notion of chain quality is used to incentivize peers to append blocks to the highest-quality chain
(the \emph{best} chain).
Therefore, a peer might replace its current best chain with another, even better chain,
a so called \emph{history change}.

As presented above, peers are free to generate new blocks at maximal speed, flood the network
with new blocks and make difficult the emergence of a best chain, with frequent history changes.
This is an efficiency and a security issue: history changes allow
\emph{double spending}, when the same money is moved in the ledger twice, once in the current history
and once in the updated history. The actual genious of Nakamoto~\cite{Nakamoto08} was to
(largely) solve this issue with a consensus rule requiring blocks to have a binary hash
that starts with at least $\delta$ zeros, directly bound to the quality of a chain.
Therefore, the creator peer (\emph{miner}) of a new block runs a \emph{proof of work} algorithm
that rotates the many possible values for a block field, called \emph{nonce}, until
the hash of the block satisfies the consensus rule. This makes the creation of new blocks hard
(for large $\delta$), makes it impossible to create blocks at arbitrary speed and introduces an
incentive to expanding the best chain, rather than creating alternative histories, since
otherwise a peer
risks spending work (concretely, electricity) for creating blocks discarded
by the other peers. The \emph{proof of work} is a brute-force algorithm,
because of the non-correlation property of hash functions.
A miner gets remunerated for its work whenever it finds a new block before all other miners.

But the proof of work consumes energy: Bitcoin is said to consume as much electricity as
a medium-sized country; moreover, mining is not egalitarian, being
worthwhile only in countries where electricity is cheap; furthermore, the proof of work
runs more efficiently in dedicated, relatively expensive hardware (such as ASICs),
which deviates much from the idea of a democratic and open network.
Therefore, the current trend is towards a\emph{proof of stake}.
This comes in different flavors, but
the shared idea is that mining is limited to a (static or dynamic, exclusive or delegatable)
set of peers, that \emph{stake} some collateral to have the right of mining.
Proof of stake has been criticized for being more centralized and less democratic
(\emph{rich becomes richer}).
Moreover, it suffers from what we call a \emph{start-up issue}: as long as the cryptocurrency
of a newborn blockchain has still no value, it is hard to convince miners to work and
be updated, since there is no incentive in doing so, initially. Starting and maintaining
a newborn blockchain becomes a social and organizational problem. Finally, miners in
a proof of stake blockchain get punished (\emph{slashed}) if they misbehave or are offline, which
might be perceived as unjust if it is the consequence of a network connectivity issue or black-out.

An alternative to proof of work and proof of stake is
\emph{proof of space}~\cite{AtenieseBFG14,DziembowskiFKP15}, where
miners must dedicate a large chunk of disk memory for mining.
Its energy consumption is almost zero and no special
hardware helps for mining, currently: the technology is both cheap
and democratic. Moreover, proof of space allows
one to capitalize on unused memory, for free, while proof of space has always an
inherent electricity cost. Most theoretical formalizations of proof of space are
based on challenges against graphs of high pebbling complexity. However, no actual blockchain
has ever been built using such theory, and only a prototype and non-maintained
implementation of the protocol exists~\cite{ParkKFGAP18}. This is maybe because of the
complex protocol, with an initialization phase
that writes a quite large proof (megabytes) in blockchain,
for each new miner that joins the network.
The only full-fledged blockchain
implementation based on proof of space is Signum~\cite{Signum}, but it is not
based on graph pebbling and misses any formalization.
There are hints that the authors of~\cite{ParkKFGAP18} have warned the developers of Signum about
theoretical issues, that the latters have allegedly solved,
but nothing has been proved nor published about it.

The contributions of this paper are
%
\begin{itemize}
\item a formalization of the proof of space algorithm of Signum;
\item a proof that the issues found by the authors of~\cite{ParkKFGAP18} have been fixed;
\item an improvement that protects against newborn attacks~\cite{TangZDWLG0L19}.
\end{itemize}
%
These results are relevant since they show that the only implementation
of a blockchain based on proof of space is actually supported by a sound theory.

We leveraged the very informal description of Signum's algorithm~\cite{SignumPlotting},
its source code~\cite{SignumSource} and the Discord chat of the project, where we contacted
its developers. However, most of our questions remained unanswered there.

The rest of this paper is organized as follows.
Sec.~\ref{sec:related_work} discusses related work.
