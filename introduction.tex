\section{Introduction}\label{sec:introduction}

Proof of retrievability~\cite{JuelsK07}: a large file
is sent from the verifier to the prover and the verifier
check, repeatedly, if the prover keeps that file in storage. It requires to transfer the file
at the beginning, for each new prover (miner).

Cite~\cite{DziembowskiFKP15}. This seems to be the first description of proofs of space.
Their algorithm is based on graph pebbling, where a vertex can be pebbled only if the
its in-going vertices have been pebbled as well. This way they prove a lower bound on the
complexity of their algorithm. They prove that that lower bound is valid also if a prover
wants to use its CPU. They prove that the size of the space used by their algorithm
is a lower bound to the execution cost of the algorithm if no space is reserved.
Therefore, using proofs of woek in a network of proofs of space nodes would
be computationally too expensive. It seems that the memory allocated in the miners
must also be allocated in the verifiers, for all miners. This would ne practically unfeasable.
To investigate further.
This is sometimes called proof of persistent space.
There is an initialization protocol for each new prover, that is missing in Burstcoin.

Cite~\cite{AtenieseBFG14}. Based on DAGs with high pebbling complexity. There are clear similarities
with~\cite{DziembowskiFKP15}. They actually cite and compare with each other.
According to~\cite{DziembowskiFKP15}, this article defines a proof of secure erasure,
that however they call a proof of space. According to~\cite{DziembowskiFKP15},
their proof of secure erasure
implies a proof of space but not the other way round. There does not seem to exist
any implementation. The issue with the size of the proofs would be identical to that
of~\cite{DziembowskiFKP15}, because of the use of pebbling graphs.
This is sometimes called proof of transient space: the puzzle function requires lot of
memory space to compute, but after computation that space con be freed.

Cite~\cite{TangZDWLG0L19}. They tackle the problem of miners using the same stored data
for many chains. This is problematic for newborn chains, since they might get an attack
from miners (or coalition of miners) that already use a very big data file for mining other,
mature chains (\emph{newborn attack}). They present a solution over the SpaceMint protocol.
The idea is that the disk space of a miner can be split for mining on many chains
simultaneously, but there is an incentive at allocating a space, for each chain, proportional
to the market value of the chain.

Cite~\cite{RenD16}. It uses stacked expander graphs, to get simpler, more efficient and
provably space-hard solutions, than~\cite{AtenieseBFG14} and~\cite{DziembowskiFKP15}.
It works for both proof of transient space and proof of persistent space.
It performs a nice comparison of previous proofs of space
and related techniques (memory-hard functions, proof of secure erasure, provable data possession,
proof of retrievability).

Cite~\cite{ParkKFGAP18}. SpaceMint, previously Spacecoin. Consideration: PoW requires power
to be allocated if mining is worthwhile. PoS allows one to allocate unused space even if its
cost is higher than mining, since in any case it would remain unused. More egalitarian:
general-purpose hardware instead of ASIC. The use of a key for the miners makes it
impossible to build mining pools, which is said to be good, citing~\cite{MillerKKS15}.
They say PoS is more difficult to adapt to blockchain because the protocol is a bit
more complicated than PoW. It lists some problems of PoS: mining multiple chains simultaneously
(since they are cheap), creating more blocks with the same proof and then choose the most
favorable (block grinding). Nothing-at-stake problems. Quality-function to determine the winner, proportional
to the allocated space. How to fight block grinding: make the proof unique, based
on who won the previous round, use
two chains, for proofs and for transactions, the proofs depends on previous proofs only.
How to fight mining on multiple chains: previous blocks affect future blocks only in a limited way.
They provide a game-theoretic model showing that the system is a Nash equilibrium.
It cites proof of storage/retrievability: the verifier must send and keep a big file.
Some link with Permacoin, which is however still a PoW system with ethical data.
It cites Burstcoin (now Signum) and its time/memory tradeoff:
``a miner doing a little extra computation can mine at the same
rate as an honest miner, while using just a small fraction (e.g., 10\%) of the space.''
It talks about a problem with miners hashing 8 million blocks, that does not seem to exist
anymore, but better check what they mean.
It cites the Chia Network (proof of space and time), \url{https://www.chia.net/}.
It calls it proof of sequential work on top of proof of space.
It says that it is based on completely different theoretical work, that is~\cite{AbusalahACKPR17}.
Consideration: their mining uses special protocol transactions
(payments, space commitments, penalties) while Mokamint is completey transaction agnostic.
Arrival of new miners and penalties for miners are kept in blockchain!
To avoid mining for different chains, the next challenge is derived from the hash of a block
(from the proof chain) deep in the past. If two children blocks are created by the same miner,
a penalty transaction is generated. The transaction includes the two blocks (it is huge!)
that are consequently signed, which guarantees that it can be verified by nodes that might
only have one history in the database.
The same challenge is used for a few consecutive blocks, to fight challenge-grinding attacks.
The size of their proofs (node pebbling) reaches 3 megabytes. This prove is stored in blockchain
for the initialization of each new miner (which might be expensive) and cheaper proofs
(100K, thanks to some ``likely sound'' optimations) are reported in each mined block.
Mokamint's deadline have constant (small size).
Code of Spacemint: \url{https://github.com/kwonalbert/spacemint}. Just a very limited prototype of a
proofs of space algorithm. Not maintained in the last nine years.

Cite~\cite{AbusalahACKPR17}. It is the theoretical base of the Chia network.
They assert that pebbling-based approaches have two main issues: the size of the proof to include in each block
(megabytes) and the initialization phase for each prover joining a verifier. That is, crypto must be spent even before
starting mining (the prover is the miner in this context) while Bitcoin allows one
to start mining and collect crypto on the way.
They solve these issues (the same is solved in Burstcoin as well).
They propose a proof of space and time based on challenges about the inversion of a random function,
overcoming the well-known issue of time-memory trade-offs.
As concisely stated in~\cite{ParkKFGAP18}, the better the quality of the proof of space, the faster the block can
be \emph{finalized} by a proof of sequential work, and this
proof tuple then can be used to create a block.

Cite~\cite{Reyzin23}. It tackles the question: how much does it cost to store only a part of the file?
When storing less than all of the file, it should be difficult for the prover to recover the
missing portions of the file when answering queries from the verifier. They define some thresholds
on the portion kept for the file and on the consequent complexity degradation. Ideally, such thresholds
should be close to 0, meaning that almost all file must be kept in memory for having no complexity
explosion. They show that existing solutions have bad constants or can be considered as impractical.
They say that the initialization protocol of the DAGs prevents most cheating (incomplete calculations).
The missing pebbles (red nodes) must be calculated later during the execution protocol.
They provide lower bounds on the cosntants of the initialization protocol so that
the resulting partial pebbling has thresholds close to 0.
This article tackles a problem that actually affected Burstcoin (its time/memory trade-offs,
theoretically now solved in Burstcoin). However, proofs in this article donot apply to Burstcoin
because it is not based on pebbling graphs.

Cite~\cite{DworkN92}. The origin of proof of work. Mail senders must compute some
work to have their email accepted by the recipient. This work includes
the address of the recipeint and the date of sending, in order to avoid
work recycling. Typically, it consists in adding extra data at the end of the email
to that its hash is smaller than a predefined constant.

Burstcoin, now Signum: \url{https://wiki.signum.network/}. Rebranded from Burstcoin.
They call it proof of capacity but it's just proof of space.
There is a very raw description of the mining algorithm:
\url{https://wiki.signum.network/signum-plotting-technical-information/index.htm}.
