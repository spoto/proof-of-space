\section{Blocks and Challenge Generation}\label{sec:challenge_generation}
%
The blocks of the blockchain contain information used for the proof
of space, called \emph{trunk} by borrowing this terminology from~\cite{CohenP19},
other information such as the previous block hash,
and extra information that is irrelevant here, such as a list of transactions.
The latter is not formalized below, since it is not used for the proof of space.
Blocks can be genesis and non-genesis. Both contain their time of creation.
Genesis blocks have nor trunk nor parent and their height is implicitly $0$.
Challenges $c$ are generated in sequence: there is an initial constant challenge for the genesis
blocks, while the subsequent challenges are generated from the trunk of
each non-genesis block $b$ of the blockchain.
In particular, $c$ is \emph{not} computed from the transactions in $b$,
in order to avoid block-grinding attacks (Sec.~\ref{sec:related_work}).
A deadline that answers $c$ is recorded in the trunk of the sons of $b$.
%
\begin{definition}[Trunk, Block]\label{def:trunk}
  The sets of \emph{trunks} and \emph{blocks} are
  \[
  \Trunks=\left\{\langle\height,\deadline\rangle\left|\;\height\in\mathbb{N}\text{ and }\deadline\in\Deadlines\right.\right\}
  \]
  \[
  \GenesisBlocks=\left\{\langle\tau\rangle\mid\tau\in\mathbb{N}\right\}
  \]
  \[
  \NonGenesisBlocks=\left\{\left\langle\begin{array}{c}
  \trunk,\tau,\alpha,\\
  \power,\weightedbeat,\\
  \previousblockhash
  \end{array}\right\rangle\left|\begin{array}{l}
  \trunk\in\Trunks,\\
  \tau\in\mathbb{N},\\
  \alpha\in\mathbb{N},\ \alpha>0,\\
  \power\in\mathbb{N},\\
  \weightedbeat\in\mathbb{N},\\
  \previousblockhash\text{ is a}\\
  \qquad\text{hash for $h_\block$}
  \end{array}\right.\right\}
  \]
  \[
  \Blocks=\GenesisBlocks\cup\NonGenesisBlocks.
  \]
\end{definition}
%
If $b$ is a block, then $b.\tau$ is its creation time (milliseconds from the Unix epoch).
If $b$ is a non-genesis block, then
$b.\alpha$ is called\footnote{In~\cite{SignumPlotting} the term
\emph{base target} is used for it, but we think that \emph{acceleration} is clearer.}
\emph{acceleration} and is used to modulate the time needed to wait for a deadline.
This acceleration changes dynamically from block to block, to cope with
the fluctuations of the mining power in the network. It is the inverse of Bitcoin's difficulty.
The value $b.\power$ expresses how much space has been used to build the path that leads to $b$,
starting from a genesis block; it will be used to select the \emph{best chain} for mining
$b$'s next block. The value of $b.\weightedbeat$ is the average of the interval creation time
for the path that leads to $b$, giving more weight to the last blocks; it will be
compared to $\beat$ (Tab.~\ref{tab:notations}) to understand if the acceleration
must be increased or decreased.
The value of $b.\previousblockhash$ is the hash of the previous block in the path leading to $b$.

The following algorithm shows how the first challenge, for genesis blocks,
its defined. It is a constant that only depends on contextual values (Table~\ref{tab:notations}).
%
\begin{alg}[$\initialchallenge$]\label{alg:initial_challenge}
  The \emph{initial challenge} is the constant
  %
  \begin{multline*}
    \initialchallenge=\\
    \langle\betonat(h_\generation(\sigma_\genesis\append\nattobe(1)))\text{ mod }\numberofscoops,\sigma_\genesis\rangle,
  \end{multline*}
  %
  where $\sigma_\genesis$ is a constant generation signature used for the genesis of the blockchain
  (see Table~\ref{tab:notations}).
\end{alg}
%
The following algorithm shows how a challenge is derived from the trunk of a non-genesis block.
%
\begin{alg}[$\nextchallenge(\trunk)$]\label{alg:next_challenge_from_trunk}
  Let $\trunk\in\Trunks$. The \emph{next challenge for $\trunk$} is
  \begin{multline*}
    \nextchallenge(\trunk)=\\
    \langle\betonat(h_\generation(\sigma\append\nattobe(\trunk.\height+1)))\text{ mod }\numberofscoops,\sigma\rangle
  \end{multline*}
  where
  \[
  \sigma=h_\generation(\trunk.\deadline.\challenge.\sigma\append\trunk.\deadline.\pi).  
  \]
\end{alg}
%
In the following, it will be handy to determine the next challenge for a block. Note that
the next definition only uses the trunk inside the block.
%
\begin{definition}\label{def:next_challenge_from_block}
  Let $b\in\Blocks$. Its \emph{next challenge} is
  \[
  \nextchallenge(b)=\begin{cases}
  \initialchallenge & \text{if $b\in\GenesisBlocks$}\\
  \nextchallenge(b.\trunk) & \text{if $b\in\NonGenesisBlocks$.}
  \end{cases}
  \]
\end{definition}

The definition of the generation signature $\sigma$ for the next challenge,
in Alg.~\ref{alg:next_challenge_from_trunk},
has puzzled us for some time, since~\cite{SignumPlotting} appends a \emph{previous block generator}
to the previous block's generation signature $\trunk.\deadline.\challenge.\sigma$.
That concept, however, is defined nowhere.
We had to dive in the source code of the Signum node
to understand that it is actually
an identifier (more concretely, the public key)
of the creator of the deadline for the previous block
(see \url{https://github.com/signum-network/signum-node/blob/main/src/brs/GeneratorImpl.java}, constructor of \<GeneratorStateImpl>).
We abstract that information through the prolog of the previous deadline, hence this is why
Alg.~\ref{alg:next_challenge_from_trunk} appends
$\trunk.\deadline.\pi$ to define $\sigma$.
This gives us the opportunity to discuss the observation in~\cite{ParkPAFG15}, page~28,
where it is stated that ``this previous block generator seems possible to be grinded, by trying
different sets of transactions to include in a block''. This is false, although it was
hard to grasp without the formalization in
Alg.~\ref{alg:next_challenge_from_trunk}, where it is clear that
$\trunk.\deadline.\pi$ comes from the trunk only, which makes
such grinding attack impossible.
