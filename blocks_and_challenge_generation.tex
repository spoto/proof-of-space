\section{Blocks and Challenge Generation}\label{sec:challenge_generation}
%
The blocks of the blockchain contain information used for the proof
of space, called \emph{trunk} by borrowing this terminology from~\cite{CohenP19},
other information such as the previous block hash,
and extra information that is irrelevant here, such as a list of transactions.
Transactions are not formalized below, since they are not used for the proof of space.
Blocks can be genesis and non-genesis. Both contain their time of creation and their acceleration.
Genesis blocks have nor trunk nor parent and their height is implicitly $0$.
Challenges $c$ are generated in sequence: there is an initial constant challenge for the genesis
blocks, while the subsequent challenges are generated from the trunk of
each non-genesis block $b$ of the blockchain.
In particular, $c$ is \emph{not} computed from the transactions in $b$,
in order to avoid block-grinding attacks (Sec.~\ref{sec:related_work}).
A deadline that answers $c$ is recorded in the trunk of the sons of $b$.
%
\begin{definition}[Trunk, Block]\label{def:trunk}
  The sets of \emph{trunks} and \emph{blocks} are
  \[
  \Trunks=\left\{\langle\height,\delta\rangle\left|\;\height\in\mathbb{N}\text{ and }\delta\in\Deadlines\right.\right\}
  \]
  \[
  \GenesisBlocks=\left\{\langle\tau,\alpha\rangle\mid\tau\in\mathbb{N},\ \alpha\in\mathbb{N}\text{ and }\alpha>0\right\}
  \]
  \[
  \NonGenesisBlocks=\left\{\left\langle\begin{array}{c}
  \tau,\alpha,\\
  \power,\weightedbeat,\\
  \trunk,\\
  \previousblockhash
  \end{array}\right\rangle\left|\begin{array}{l}
  \tau\in\mathbb{N},\\
  \alpha\in\mathbb{N},\ \alpha>0,\\
  \power\in\mathbb{N},\\
  \weightedbeat\in\mathbb{N},\\
  \trunk\in\Trunks,\\
  \previousblockhash\text{ is a}\\
  \qquad\text{hash for $h_\block$}
  \end{array}\right.\right\}
  \]
  \[
  \Blocks=\GenesisBlocks\cup\NonGenesisBlocks.
  \]
\end{definition}
%
If $b$ is a block, then $b.\tau$ is its creation time (milliseconds from the Unix epoch)
and $b.\alpha$ is the acceleration at $b$. If $b$ is a non-genesis block, then
$b.\power$ expresses how much space has been used to build the path that leads to $b$,
starting from the genesis block; it will be used to select the \emph{best chain} for mining
$b$'s son. The value of $b.\weightedbeat$ is the average of the interval creation time
for the path that leads to $b$, giving more weight to the last blocks; it will be
compared to $\beat$ (Tab.~\ref{tab:notations}) to understand if the acceleration
must be increased or decreased in $b$'s son.
The value of $b.\previousblockhash$ is the hash of the previous block in the path leading to $b$.
If $b$ is a genesis block, we abuse notation and assume that $b.\power=b.\weightedbeat=0$.

\begin{definition}[Block's height]\label{def:block_height}
  Let $b\in\Blocks$. The \emph{height} of $b$ is defined as
  \[
  \height(b)=\begin{cases}
  0 & \text{if $b\in\GenesisBlocks$}\\
  b.\trunk.\height & \text{if $b\in\NonGenesisBlocks$.}
  \end{cases}
  \]
\end{definition}

The following algorithm shows how the first challenge, for genesis blocks,
its defined. It is a constant that only depends on contextual values (Table~\ref{tab:notations}).
%
\begin{alg}[$\initialchallenge$]\label{alg:initial_challenge}
  The \emph{initial challenge} is the constant
  %
  \begin{multline*}
    \initialchallenge=\\
    \langle\betonat(h_\generation(\sigma_\genesis\append\nattobe(1)))\text{ mod }\numberofscoops,\sigma_\genesis\rangle,
  \end{multline*}
  %
  where $\sigma_\genesis$ is a constant generation signature used for the genesis of the blockchain
  (see Table~\ref{tab:notations}).
\end{alg}
%
The following algorithm shows how a challenge is derived from the trunk of a non-genesis block.
%
\begin{alg}[$\nextchallenge(\trunk)$]\label{alg:next_challenge_from_trunk}
  Let $\trunk\in\Trunks$. The \emph{next challenge for $\trunk$} is
  \begin{multline*}
    \nextchallenge(\trunk)=\\
    \langle\betonat(h_\generation(\sigma\append\nattobe(\trunk.\height+1)))\text{ mod }\numberofscoops,\sigma\rangle
  \end{multline*}
  where
  \[
  \sigma=h_\generation(\trunk.\delta.\challenge.\sigma\append\trunk.\delta.\pi).  
  \]
\end{alg}
%
The definition of the generation signature $\sigma$ for the next challenge,
in Alg.~\ref{alg:next_challenge_from_trunk},
has puzzled us for some time, since~\cite{SignumPlotting} appends a \emph{previous block generator}
to the previous block's generation signature $\trunk.\delta.\challenge.\sigma$.
That concept, however, is defined nowhere.
We had to dive in the source code of the Signum node
to understand that it is actually
an identifier (more concretely, the public key)
of the creator of the deadline for the previous block
(see \url{https://github.com/signum-network/signum-node/blob/main/src/brs/GeneratorImpl.java}, constructor of \<GeneratorStateImpl>).
We abstract that information through the prolog of the previous deadline, hence this is why
Alg.~\ref{alg:next_challenge_from_trunk} appends
$\trunk.\delta.\pi$ to define $\sigma$.
This gives us the opportunity to discuss the observation in~\cite{ParkPAFG15}, page~28,
where it is stated that ``this previous block generator seems possible to be grinded, by trying
different sets of transactions to include in a block''. This is false, although it was
hard to grasp without the formalization in
Alg.~\ref{alg:next_challenge_from_trunk}, where it is clear that
$\trunk.\delta.\pi$ comes from the trunk only, which makes
such grinding attack impossible.

Later, it will be handy to determine the next challenge for a block. Note that
the next definition only uses the trunk inside the block.
%
\begin{definition}\label{def:next_challenge_from_block}
  Let $b\in\Blocks$. Its \emph{next challenge} is
  \[
  \nextchallenge(b)=\begin{cases}
  \initialchallenge & \text{if $b\in\GenesisBlocks$}\\
  \nextchallenge(b.\trunk) & \text{if $b\in\NonGenesisBlocks$.}
  \end{cases}
  \]
\end{definition}

In the following, it is shown how the information inside a block is used to construct
the information inside its son(s). The computation of the next weighted beat
gives more or less weight to the previous weighted beat, depending on a constant $\oblivion$.
Therefore, the latter ($0\le\oblivion\le 1$) expresses how quickly the acceleration reacts to changes
in mining power. The computation of the next power uses the same formula of Bitcoin~\cite{WalkerG24},
adapted to our context: the maximal (hence worse) deadline's value $2^{8\cdot\size(h_\deadline)}$ is compared
to the actual deadline's value and their ratio expresses how much space has been used to compute the deadline.
%
\begin{definition}[Next functions]\label{def:next}
  Let $b\in\Blocks$ and $\delta\in\Deadlines$. We define
  \[
  \nextwaitingtime(b,\delta)=b.\tau+\waitingtime(\delta,b.\alpha)
  \]
  \[
  \nextweightedbeat(b,\delta)=\begin{array}{c}
  \waitingtime(\delta,b.\alpha)\cdot\oblivion\\
  +b.\weightedbeat\cdot(1-\oblivion)
  \end{array}
  \]
  \[
  \nextacceleration(b,\delta)=\frac{b.\alpha\cdot\nextweightedbeat(b,\delta)}{\beat}
  \]
  \[
  \nextpower(b,\delta)=b.\power+\frac{2^{8\cdot\size(h_\deadline)}}{\betonat(\delta.\mathit{value})+1}
  \]
\end{definition}
%
\begin{definition}[Next block]\label{def:next_block}
  Let $b\in\Blocks$ and $\delta\in\Deadlines$. We define
  $\nextblock(b,\delta)\in\NonGenesisBlocks$ as
  \[
  \nextblock(b,\delta)=\left\langle\begin{array}{c}
  \nextwaitingtime(b,\delta),\nextacceleration(b,\delta),\\
  \nextpower(b,\delta),\nextweightedbeat(b,\delta),\\
  \langle\height(b)+1,\delta\rangle,\\
  h_\block(b)
  \end{array}\right\rangle.
  \]
\end{definition}
