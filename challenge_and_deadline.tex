\section{Challenges and Deadlines}\label{sec:challenges_and_deadlines}

A \emph{challenge} specifies a puzzle that must be solved in order to mine
a new block. In Signum, challenges become a query that can be asked to a nonce, resulting
in an answer called \emph{deadline}.
%Challenges will be applied to plots by taking the \emph{smallest} deadline over their nonces.
%
\begin{definition}[Challenge]\label{def:challenge}
  The set of \emph{challenges} is
  \[
  \Challenges=\left\{\langle\scoopnumber,\sigma\rangle\left|
  \begin{array}{l}
    0\le\scoopnumber<\numberofscoops\\
    \text{and $\sigma$ is a hash for $h_\generation$}
  \end{array}
  \right.\right\}.
  \]
  The $\sigma$ component of a challenge is said to be its \emph{generation signature}.
  In the following, generation signature will be used as a synonym of hash for $h_\generation$.
\end{definition}
%
Given a challenge and a nonce, the latter has a value that specifies how well
the nonce answers the challenge.
%
\begin{definition}[$\mathit{value}(\nonce,\challenge)$]\label{def:nonce_value}
  Let $\nonce\in\Nonces$ and $\challenge\in\Challenges$.
  The \emph{value of $\nonce$ \wrt $\challenge$} is defined as
  %
  \begin{multline*}
    \mathit{value}(\nonce,\challenge)\\
    =h_\deadline(\nonce.\scoops[\challenge.\scoopnumber]\append\challenge.\sigma).
  \end{multline*}
\end{definition}
%
The answer to a challenge could actually be a nonce $n$, whose quality is its value.
But nonces are relatively big (around $262$ kbytes under the assumptions in the
rightmost column of Tab.~\ref{tab:notations}). Since answers are stored in blockchain,
\cite{SignumPlotting}~introduces \emph{deadlines}, a much smaller representation of the value of
$n$, carrying the information needed to reconstruct $n$ and verify that it actually
answers the challenge.
%
\begin{definition}[Deadline]\label{def:deadline}
  The set of \emph{deadlines} is
  \[
  \Deadlines=\left\{
  \langle p,\pi,\mathit{value},\challenge\rangle
  \left|\begin{array}{l}
  \pi\in\Prologs,\ p\in\mathbb{N},\\
  \mathit{value}\text{ is a hash for }h_\deadline\\
  \text{and }\challenge\in\Challenges
  \end{array}
  \right.
  \right\}.
  \]
  Deadlines are totally ordered by increasing value.
\end{definition}
%
Intuitively, the value of a deadline expresses how many milliseconds
must be waited until the deadline expires and a new block can be mined.
However, if the mining power of the network increases, the minimal value of the deadlines
generated by the network tends to decrease and the block creation rate would not be
fixed to $\beat$ (Tab.~\ref{tab:notations}), on average.
This explains why the deadlines value is modulated \wrt an
\emph{acceleration}\footnote{In~\cite{SignumPlotting} the term
\emph{base target} is used for it, but we think that \emph{acceleration} is clearer.},
which is the inverse of Bitcoin's difficulty.
%
\begin{definition}[Deadline's waiting time]\label{def:deadline_waiting_time}
  Given $\delta\in\Deadlines$ and an \emph{acceleration}
  $\alpha\in\mathbb{N}$ such that $\alpha>0$, the
  \emph{waiting time} for $\delta$ \wrt $\alpha$ is\footnote{
  In~\cite{SignumPlotting}, the divisor is actually
  $2^{\size(h_\deadline)-8}\cdot\alpha$, to avoid using very large values for
  $\alpha$. This is theoretically irrelevant and we prefer our simpler presentation.
  }
  %
  \[
  \waitingtime(\delta,\alpha)
  %  =\betonat\left(\text{first $8$ bytes of}\left(\nattobe\left(\frac{\betonat(\delta.\mathit{value})}{\alpha}\right)\right)\right).
  =\frac{\betonat(\delta.\mathit{value})}{\alpha}.
  \]
\end{definition}
%
Def.~\ref{def:deadline_from_nonce} finally shows how a nonce answers a challenge with a deadline.
%
\begin{definition}[$\delta(\nonce,\pi,\challenge)$]\label{def:deadline_from_nonce}
  Given $\nonce\in\Nonces$, $\pi\in\Prologs$ and $\challenge\in\Challenges$, the
  \emph{deadline computed from $\nonce$ for $\pi$ and $\challenge$} is
  $\delta(\nonce,\pi,\challenge)=\langle\nonce.p,\pi,\mathit{value}(\nonce,\challenge),\challenge\rangle$.
\end{definition}
%
Def.~\ref{def:deadline_from_nonce} extends to plots. Remember that plots are non-empty
(Def.~\ref{def:plot}) and embed the identifier of their creator $\pi$;
and that deadlines are ordered by their value.
%
\begin{definition}[$\deadline(\plot,\challenge)$]\label{def:deadline_from_plot}
  Given $\plot\in\Plots$ and $\challenge\in\Challenges$, the \emph{deadline computed
  from $\plot$ for $\challenge$} is\footnote{If more nonces of the plot lead to deadlines
  with the same minimal value, we assume that Def.~\ref{def:deadline_from_plot} chooses one,
  according to some policy that is irrelevant here.}
  \[
  \delta(\plot,\challenge)=\min\limits_{\nonce\in\plot.\nonces}\delta(\nonce,\plot.\pi,\challenge).
  \]
\end{definition}
%
A deadline is valid when the nonce built from its progressive and prolog
has the same value as the deadline \wrt its challenge.
%
\begin{definition}[Deadline's validity]\label{def:deadline_validity}
  Given $\delta\in\Deadlines$, it is \emph{valid} if and only if
  $\delta.\mathit{value}=\mathit{value}(\nonce(\delta.p,\delta.\pi),\delta.\challenge)$.
\end{definition}
%
%Later, the consensus rules of the blockchain (Def.~\ref{def:blockchain})
%will check that deadlines are valid. Therefore, one could be tempted to
%avoid such check by removing the $\mathit{value}$ field from deadlines
%(Def.~\ref{def:deadline}) and computing
%their value, on demand, by Def.~\ref{def:deadline_validity}. However, the
%computation of
%$\nonce(\delta.p,\delta.\pi)$ is relatively expensive in terms of amount of hashed data
%(Def.~\ref{alg:nonce_construction}).
%Therefore, the original informal description~\cite{SignumPlotting} puts the value in the deadlines
%and we follow that approach.
