\section{Challenges and Deadlines}\label{sec:challenges_and_deadlines}

A \emph{challenge} specifies a query that can be asked to a nonce.
The answer will be a \emph{deadline}.
Challenges will be applied to plots as well, by taking
the \emph{smallest} deadline for each nonce in the plot.
%
\begin{definition}[Challenge]\label{def:challenge}
  The set of \emph{challenges} is
  \[
  \Challenges=\left\{\langle\scoopnumber,\sigma\rangle\left|
  \begin{array}{l}
    0\le\scoopnumber<\numberofscoops\\
    \text{and $\sigma$ is a hash for $h_\generation$}
  \end{array}
  \right.\right\}.
  \]
  The $\sigma$ component of a challenge is said to be its \emph{generation signature}.
\end{definition}
%
In the following, generation signature will be used as a synonym of hash for $h_\generation$.
%
\begin{definition}[Deadline]\label{def:deadline}
  The set of \emph{deadlines} is
  \[
  \Deadlines=\left\{
  \langle p,\pi,\mathit{value},\challenge\rangle
  \left|\begin{array}{l}
  \pi\in\Prologs,\ p\in\mathbb{N}\\
  \mathit{value}\text{ is a hash for }h_\deadline\\
  \text{and }\challenge\in\Challenges
  \end{array}
  \right.
  \right\}
  \]
  Deadlines are totally ordered by increasing value.
\end{definition}
%
Intuitively, the value of a deadline is related to the length, in milliseconds, of the time
that must be waited until the deadline expires and a new block can be mined.
However, if the mining power of the network increases, the minimal value of the deadlines
generated by the network
tends to decrease, and vice versa. That is, the block creation rate would not be
fixed to $\beat$ (Tab.~\ref{tab:notations}), on average.
This explains why we need to modulate the value of the deadlines \wrt a number
called \emph{acceleration}, which is the opposite of Bitcoin's difficulty.
%
\begin{definition}[Deadline's waiting time]\label{def:deadline}
  Given $\deadline\in\Deadlines$ and an \emph{acceleration}
  $\alpha\in\mathbb{N}$ such that $\alpha>0$, the
  \emph{waiting time} for $\deadline$ \wrt $\alpha$ is
  %
  \begin{multline*}
    \waitingtime(\deadline,\alpha)\\
    =\betonat\left(\text{first $8$ bytes of}\left(\nattobe\left(\frac{\betonat(\deadline.\mathit{value})}{\alpha}\right)\right)\right).
  \end{multline*}
\end{definition}
%
The following algorithm shows how a nonce answers a challenge with a deadline.
%
\begin{alg}[$\deadline(\nonce,\pi,\challenge)$]\label{alg:deadline_from_nonce}
  Given $\nonce\in\Nonces$, $\pi\in\Prologs$ and $\challenge\in\Challenges$, the
  \emph{deadline computed from $\nonce$ for $\pi$ and $\challenge$} is
  \[
  \deadline(\nonce,\pi,\challenge)=\langle\nonce.p,\pi,\mathit{value},\challenge\rangle
  \]
  where
  \[
  \mathit{value}=h_\deadline(\nonce.\scoops[\challenge.\scoopnumber]\append\challenge.\sigma).
  \]
\end{alg}
%
Alg.~\ref{alg:deadline_from_nonce} is extended to plots. Remember that plots are non-empty
(Def.~\ref{def:plot}) and that deadlines are ordered by their value.
%
\begin{alg}[$\deadline(\plot,\challenge)$]\label{alg:deadline_from_plot}
  Given $\plot\in\Plots$ and $\challenge\in\Challenges$, the \emph{deadline computed
  from $\plot$ for $\challenge$} is
  \[
  \deadline(\plot,\challenge)=\min\limits_{\nonce\in\plot.\nonces}\deadline(\nonce,\plot.\pi,\challenge).
  \]
\end{alg}
